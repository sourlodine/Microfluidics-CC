.. _user-udevicex:

uDeviceX coordinator
######################

The coordinator class stiches together data containers, :ref:`user-pv`, and all the handlers,
and provides functions to manipulate the system components.

One and only one instance of this class should be created in the beginning of any simulation setup

.. autoclass:: udevicex.udevicex
   :members:
   :show-inheritance:
   :undoc-members:
   :special-members: __init__
      
 

.. py:class:: udevicex
   :module: udevicex

   Bases: :class:`pybind11_builtins.pybind11_object`

Main coordination class, should only be one instance at a time


.. py:method:: udevicex.__init__(self: libudevicex.udevicex, nranks: Tuple[int, int, int], domain: Tuple[float, float, float], log_filename: str = 'log', debug_level: int = 3, checkpoint_every: int = 0, restart_folder: str = 'restart/', cuda_aware_mpi: bool = False) -> None
   :module: udevicex

:param nranks: number of MPI simulation tasks per axis: x,y,z. If postprocess is enabled, the same number of the postprocess tasks will be running
:param domain: size of the simulation domain in x,y,z. Periodic boundary conditions are applied at the domain boundaries.
               The domain will be split in equal chunks between the MPI ranks.
               The largest chunk size that a single MPI rank can have depends on the total number of particles,
               handlers and hardware, and is typically about :math:`120^3 - 200^3`.
:param log_filename: prefix of the log files that will be created. Logging is implemented in the form of one file per MPI rank, so in the simulation folder NP files with names log_00000.log, log_00001.log, ... will be created, where NP is the total number of MPI ranks. Each MPI task (including postprocess) writes messages about itself into his own log file, and the combined log may be created by merging all the individual ones and sorting with respect to time.
                     If this parameter is set to 'stdout' or 'stderr' standard output or standard error streams will be used instead of the file, however, there is no guarantee that messages from different ranks are synchronized
:param debug_level: | Debug level varies from 1 to 8:
                    |
                    | #. only report fatal errors
                    | #. report serious errors
                    | #. report warnings (this is the default level)
                    | #. report not critical information
                    | #. report some debug information
                    | #. report more debug
                    | #. report all the debug
                    | #. force flushing to the file after each message
                    |
                    | Debug levels above 4 or 5 may significanlty increase the runtime, they are only recommended to debug errors.
                    | Flushing increases the runtime yet more, but it is required in order not to lose any messages in case of abnormal program abort.
:param checkpoint_every: save state of the simulation components (particle vectors and handlers like integrators, plugins, etc.)
:param restart_folder: folder where the checkpoint files will reside
:param cuda_aware_mpi: enable CUDA Aware MPI (GPU RDMA). As of now it may crash, or may yield slower execution.


.. py:method:: udevicex.applyObjectBelongingChecker(self: libudevicex.udevicex, checker: ObjectBelongingChecker, pv: ParticleVector, correct_every: int = 0, inside: str = '', outside: str = '') -> ParticleVector
   :module: udevicex

Apply the **checker** to the given particle vector.
One and only one of the options **inside** or **outside** has to be specified.

:param checker: instance of :any:`BelongingChecker`
:param pv: :any:`ParticleVector` that will be split (source PV)
:param inside: if specified and not "none", a new :any:`ParticleVector` with name **inside** will be returned, that will keep the inner particles of the source PV. If set to "none", None object will be returned. In any case, the source PV will only contain the outer particles
:param outside: if specified and not "none", a new :any:`ParticleVector` with name **outside** will be returned, that will keep the outer particles of the source PV. If set to "none", None object will be returned. In any case, the source PV will only contain the inner particles
:param correct_every: If greater than zero, perform correction every this many time-steps.
                      Correction will move e.g. *inner* particles of outer PV to the :inner PV
                      and viceversa. If one of the PVs was defined as "none", the 'wrong' particles will be just removed.

:returns: New :any:`ParticleVector` or None depending on **inside** and **outside** options


.. py:method:: udevicex.isComputeTask(self: libudevicex.udevicex) -> bool
   :module: udevicex

Returns whether current rank will do compute or postrprocess


.. py:method:: udevicex.isMasterTask(self: libudevicex.udevicex) -> bool
   :module: udevicex

Returns whether current task is the very first one


.. py:method:: udevicex.makeFrozenWallParticles(self: libudevicex.udevicex, wall: Wall, interaction: Interaction, integrator: Integrator, density: float, nsteps: int = 1000) -> ParticleVector
   :module: udevicex

Create particles frozen inside the wall.

.. note::
    A separate simulation will be run for every call to this function, which may take certain amount of time.
    If you want to save time, consider using restarting mechanism instead

:param wall: instance of :any:`Wall` for which the frozen particles will be generated
:param interaction: this :any:`Interaction` will be used to construct the equilibrium particles distribution
:param integrator: this :any:`Integrator` will be used to construct the equilibrium particles distribution
:param density: target particle density
:param nsteps: run this many steps to achieve equilibrium

:returns: New :any:`ParticleVector` that will contain particles that are close to the wall boundary, but still inside the wall.


.. py:method:: udevicex.registerBouncer(self: libudevicex.udevicex, arg0: Bouncer) -> None
   :module: udevicex

Register Object Bouncer


.. py:method:: udevicex.registerIntegrator(self: libudevicex.udevicex, arg0: Integrator) -> None
   :module: udevicex

Register Integrator


.. py:method:: udevicex.registerInteraction(self: libudevicex.udevicex, arg0: Interaction) -> None
   :module: udevicex

Register Interaction


.. py:method:: udevicex.registerObjectBelongingChecker(self: libudevicex.udevicex, checker: ObjectBelongingChecker, ov: ObjectVector) -> None
   :module: udevicex

Register Object Belonging Checker

:param checker: instance of :any:`BelongingChecker`
:param ov: :any:`ObjectVector` belonging to which the **checker** will check


.. py:method:: udevicex.registerParticleVector(self: libudevicex.udevicex, pv: ParticleVector, ic: InitialConditions = None, checkpoint_every: int = 0) -> None
   :module: udevicex

Register particle vector

:param pv: :any:`ParticleVector`
:param ic: :class:`~libudevicex.InitialConditions.InitialConditions` that will generate the initial distibution of the particles
:param checkpoint_every: every that many timesteps the state of the Particle Vector across all the MPI processes will be saved to disk  into the ./restart/ folder. The checkpoint files may be used to restart the whole simulation or only some individual PVs from the saved states. Default value of 0 means no checkpoint.


.. py:method:: udevicex.registerPlugins(self: libudevicex.udevicex, arg0: SimulationPlugin, arg1: PostprocessPlugin) -> None
   :module: udevicex

Register Plugins


.. py:method:: udevicex.registerWall(self: libudevicex.udevicex, arg0: Wall, arg1: int) -> None
   :module: udevicex

Register Wall


.. py:method:: udevicex.run(self: libudevicex.udevicex, arg0: int) -> None
   :module: udevicex

Run the simulation


.. py:method:: udevicex.setBouncer(self: libudevicex.udevicex, arg0: Bouncer, arg1: ObjectVector, arg2: ParticleVector) -> None
   :module: udevicex

Set Bouncer


.. py:method:: udevicex.setIntegrator(self: libudevicex.udevicex, arg0: Integrator, arg1: ParticleVector) -> None
   :module: udevicex

Set Integrator


.. py:method:: udevicex.setInteraction(self: libudevicex.udevicex, interaction: Interaction, pv1: ParticleVector, pv2: ParticleVector) -> None
   :module: udevicex

Forces between two Particle Vectors (they can be the same) *name1* and *name2* will be computed according to the defined interaction.


.. py:method:: udevicex.setWall(self: libudevicex.udevicex, arg0: Wall, arg1: ParticleVector) -> None
   :module: udevicex

Set Wall

