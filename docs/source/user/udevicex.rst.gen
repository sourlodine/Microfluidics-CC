.. _user-udevicex:

uDeviceX coordinator
######################

The coordinator class stiches together data containers, :ref:`user-pv`, and all the handlers,
and provides functions to manipulate the system components.

One and only one instance of this class should be created in the beginning of any simulation setup

.. comment _udevicex
   :members:
   :show-inheritance:
   :undoc-members:
   :special-members: __init__
      
 

.. py:module:: _udevicex


.. py:class:: udevicex
   :module: _udevicex

   Bases: :class:`pybind11_builtins.pybind11_object`


.. py:method:: udevicex.__init__(self: _udevicex.udevicex, nranks: Tuple[int, int, int], domain: Tuple[float, float, float], log_filename: str = 'log', debug_level: int = 3, cuda_aware_mpi: bool = False) -> None
   :module: _udevicex


.. py:method:: udevicex.applyObjectBelongingChecker(self: _udevicex.udevicex, checker: ObjectBelongingChecker, pv: ParticleVector, correct_every: int = 0, inside: str = '', outside: str = '') -> ParticleVector
   :module: _udevicex

Apply the **checker** to the given particle vector.
One and only one of the options **inside** or **outside** has to be specified.

:param checker: instance of :class:`ObjectBelongingChecker`
:param pv: :class:`ParticleVector` that will be split (source PV)
:param inside: if specified and not "none", a new :class:`ParticleVector` with name **inside** will be returned, that will keep the inner particles of the source PV. If set to "none", None object will be returned. In any case, the source PV will only contain the outer particles
:param outside: if specified and not "none", a new :class:`ParticleVector` with name **outside** will be returned, that will keep the outer particles of the source PV. If set to "none", None object will be returned. In any case, the source PV will only contain the inner particles
:param correct_every: If greater than zero, perform correction every this many time-steps.
                      Correction will move e.g. *inner* particles of outer PV to the :inner PV
                      and viceversa. If one of the PVs was defined as "none", the 'wrong' particles will be just removed.

:returns: New :class:`ParticleVector` or None depending on **inside** and **outside** options


.. py:method:: udevicex.isComputeTask(self: _udevicex.udevicex) -> bool
   :module: _udevicex

Returns whether current rank will do compute or postrprocess


.. py:method:: udevicex.registerBouncer(self: _udevicex.udevicex, arg0: Bouncer) -> None
   :module: _udevicex

Register Object Bouncer


.. py:method:: udevicex.registerIntegrator(self: _udevicex.udevicex, arg0: Integrator) -> None
   :module: _udevicex

Register Integrator


.. py:method:: udevicex.registerInteraction(self: _udevicex.udevicex, arg0: Interaction) -> None
   :module: _udevicex

Register Interaction


.. py:method:: udevicex.registerObjectBelongingChecker(self: _udevicex.udevicex, checker: ObjectBelongingChecker, ov: ObjectVector) -> None
   :module: _udevicex

Register Object Belonging Checker

:param checker: instance of :class:`ObjectBelongingChecker`
:param ov: :class:`ObjectVector` belonging to which the **checker** will check


.. py:method:: udevicex.registerParticleVector(self: _udevicex.udevicex, pv: ParticleVector, ic: InitialConditions, checkpoint_every: int = 0) -> None
   :module: _udevicex

Register Particle Vector


.. py:method:: udevicex.registerPlugins(self: _udevicex.udevicex, arg0: SimulationPlugin, arg1: PostprocessPlugin) -> None
   :module: _udevicex

Register Plugins


.. py:method:: udevicex.registerWall(self: _udevicex.udevicex, arg0: Wall, arg1: int) -> None
   :module: _udevicex

Register Wall


.. py:method:: udevicex.run(self: _udevicex.udevicex, arg0: int) -> None
   :module: _udevicex

Run the simulation


.. py:method:: udevicex.setBouncer(self: _udevicex.udevicex, arg0: Bouncer, arg1: ObjectVector, arg2: ParticleVector) -> None
   :module: _udevicex

Set Bouncer


.. py:method:: udevicex.setIntegrator(self: _udevicex.udevicex, arg0: Integrator, arg1: ParticleVector) -> None
   :module: _udevicex

Set Integrator


.. py:method:: udevicex.setInteraction(self: _udevicex.udevicex, interaction: Interaction, pv1: ParticleVector, pv2: ParticleVector) -> None
   :module: _udevicex

Forces between two Particle Vectors (they can be the same) *name1* and *name2* will be computed according to the defined interaction.


.. py:method:: udevicex.setWall(self: _udevicex.udevicex, arg0: Wall, arg1: ParticleVector) -> None
   :module: _udevicex

Set Wall

